name: PR Coverage on Label

on:
  pull_request:
    types: [opened, synchronize, labeled, reopened]

permissions:
  contents: read
  pull-requests: write

concurrency:
  group: coverage-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  run-tests-and-coverage:
    if: |
      github.event.pull_request.base.ref == 'main' &&
      contains(github.event.pull_request.labels.*.name, 'run_ci') &&
      github.event.pull_request.head.repo.full_name == github.repository
    runs-on: macos-latest
    timeout-minutes: 45

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          fetch-depth: 1

      - name: Setup Latest Stable Xcode
        run: |
          if [ -d "/Applications/Xcode.app" ]; then
            SELECTED_XCODE="Xcode.app"
          else
            SELECTED_XCODE=$(ls /Applications | grep "^Xcode" | grep -v -i beta | grep -v -i "RC" | grep -v -i preview | sort -V | tail -1)
          fi
          
          sudo xcode-select -s /Applications/$SELECTED_XCODE/Contents/Developer
          xcodebuild -version

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install PyYAML
        run: pip install pyyaml

      - name: Find Available Simulator
        id: simulator
        run: |
          RUNTIME=$(xcrun simctl list runtimes iOS -j | jq -r '.runtimes | map(select(.isAvailable == true)) | sort_by(.version) | last | .identifier')
          DEVICE_UDID=$(xcrun simctl list devices -j | jq -r --arg runtime "$RUNTIME" '.devices[$runtime] | .[]? | select(.name | contains("iPhone")) | .udid' | head -1)
          
          if [ -z "$DEVICE_UDID" ]; then
            DEVICE_TYPE=$(xcrun simctl list devicetypes -j | jq -r '.devicetypes | map(select(.name | contains("iPhone"))) | last | .identifier')
            DEVICE_UDID=$(xcrun simctl create "CI-iPhone" "$DEVICE_TYPE" "$RUNTIME")
          fi
          
          xcrun simctl boot "$DEVICE_UDID" 2>/dev/null || true
          sleep 3
          
          echo "DEVICE_UDID=$DEVICE_UDID" >> $GITHUB_OUTPUT

      - name: Run All Module Tests
        env:
          SCHEME: "GithubActions"
          DEVICE_UDID: ${{ steps.simulator.outputs.DEVICE_UDID }}
        run: |
          echo "üß™ Running ALL module tests..."
          echo "This includes:"
          echo "  - CheckoutTests"
          echo "  - HelpCentreKitImplTests"
          echo "  - LoginModuleTests"
          echo "  - MAnalyticsTests"
          echo "  - MeeshoCommonTests"
          echo "  - And any other test targets"
          echo ""
          
          START_TIME=$(date +%s)
          
          # Run all tests (no -only-testing filter)
          # This will run all test bundles in the scheme
          xcodebuild test \
            -workspace GithubActions.xcworkspace \
            -scheme "$SCHEME" \
            -destination "platform=iOS Simulator,id=$DEVICE_UDID" \
            -skip-testing:GithubActionsUITests \
            -enableCodeCoverage YES \
            -resultBundlePath TestResults.xcresult \
            -derivedDataPath DerivedData \
            CODE_SIGN_IDENTITY="" \
            CODE_SIGNING_REQUIRED=NO
          
          END_TIME=$(date +%s)
          echo ""
          echo "‚úÖ All tests completed in $((END_TIME - START_TIME)) seconds"

      - name: Generate Project-Wide Coverage Report
        if: always()
        run: |
          if [ ! -d "TestResults.xcresult" ]; then
            echo "‚ùå No TestResults.xcresult"
            exit 1
          fi
          
          echo "üìä Generating project-wide coverage report..."
          xcrun xccov view --report --json TestResults.xcresult > coverage.json
          
          echo ""
          echo "üìä Coverage Summary by Target:"
          cat coverage.json | jq -r '.targets[] | "\(.name): \(.lineCoverage * 100 | floor)% (\(.coveredLines)/\(.executableLines) lines)"'
          
          echo ""
          echo "üìä Total project coverage (before filtering):"
          cat coverage.json | jq '{coveredLines: .coveredLines, executableLines: .executableLines, lineCoverage: (.lineCoverage * 100)}'
          
          echo ""
          echo "üìä Converting to LCOV format..."
          
          python3 << 'PYEOF'
          import json
          
          with open("coverage.json") as f:
              data = json.load(f)
          
          total_files = 0
          
          with open("coverage.lcov", "w") as out:
              for target in data.get("targets", []):
                  target_name = target.get("name", "")
                  
                  for file_data in target.get("files", []):
                      path = file_data.get("path", "")
                      if not path:
                          continue
                      
                      total_files += 1
                      
                      out.write(f"TN:{target_name}\n")
                      out.write(f"SF:{path}\n")
                      
                      # Functions
                      functions = file_data.get("functions", [])
                      if isinstance(functions, list):
                          for func in functions:
                              name = func.get("name", "")
                              line = func.get("lineNumber", 0)
                              if name and line:
                                  out.write(f"FN:{line},{name}\n")
                          
                          for func in functions:
                              name = func.get("name", "")
                              count = func.get("executionCount", 0)
                              if name:
                                  out.write(f"FNDA:{count},{name}\n")
                          
                          out.write(f"FNF:{len(functions)}\n")
                          out.write(f"FNH:{sum(1 for f in functions if f.get('executionCount', 0) > 0)}\n")
                      
                      # Lines
                      executable_lines = file_data.get("executableLines", 0)
                      line_coverage = file_data.get("lineCoverage", 0.0)
                      
                      if executable_lines > 0:
                          covered = int(executable_lines * line_coverage)
                          out.write(f"LF:{executable_lines}\n")
                          out.write(f"LH:{covered}\n")
                      
                      out.write("end_of_record\n")
          
          print(f"‚úÖ Generated LCOV for {total_files} files")
          PYEOF

      - name: Filter Coverage using .xcodecov.yaml
        if: always()
        run: |
          echo "üîç ===== COVERAGE FILTERING ====="
          echo ""
          
          CONFIG_FILE="ci_scripts/scripts/.xcodecov.yaml"
          
          if [ -f "$CONFIG_FILE" ]; then
            echo "‚úÖ Found configuration file: $CONFIG_FILE"
            echo ""
            echo "üìÑ Exclusion patterns (first 20):"
            head -20 "$CONFIG_FILE"
            echo "..."
          else
            echo "‚ùå Configuration file not found: $CONFIG_FILE"
            exit 1
          fi
          
          # Show stats BEFORE filtering
          echo ""
          echo "üìä BEFORE Filtering:"
          BEFORE_FILES=$(grep -c "^SF:" coverage.lcov)
          BEFORE_LF=$(grep "^LF:" coverage.lcov | awk -F: '{sum+=$2} END {print sum+0}')
          BEFORE_LH=$(grep "^LH:" coverage.lcov | awk -F: '{sum+=$2} END {print sum+0}')
          BEFORE_COV=$(awk "BEGIN {printf \"%.2f\", ($BEFORE_LH/$BEFORE_LF)*100}")
          
          echo "  Files: $BEFORE_FILES"
          echo "  Lines: $BEFORE_LH / $BEFORE_LF ($BEFORE_COV%)"
          
          # Apply filtering
          python3 << 'PYEOF'
          import yaml
          import re
          import os
          
          config_file = "ci_scripts/scripts/.xcodecov.yaml"
          
          print(f"\nüö´ Loading exclusion patterns from {config_file}...")
          
          with open(config_file, 'r') as f:
              config = yaml.safe_load(f)
          
          ignore_patterns = config.get('ignore', [])
          print(f"   Found {len(ignore_patterns)} exclusion patterns")
          
          # Read LCOV
          with open("coverage.lcov", "r") as f:
              content = f.read()
          
          blocks = content.split("end_of_record\n")
          
          filtered_blocks = []
          included_count = 0
          excluded_count = 0
          excluded_by_pattern = {}
          
          for block in blocks:
              if not block.strip():
                  continue
              
              # Extract file path
              sf_line = None
              for line in block.strip().split("\n"):
                  if line.startswith("SF:"):
                      sf_line = line[3:]
                      break
              
              if not sf_line:
                  continue
              
              # Check against all patterns
              exclude = False
              matched_pattern = None
              
              # Exclude Pods
              if "/Pods/" in sf_line or "/Pods\\" in sf_line:
                  exclude = True
                  matched_pattern = "Pods"
              
              # Check YAML patterns
              if not exclude:
                  for pattern in ignore_patterns:
                      # Convert glob to regex
                      regex_pattern = pattern.replace('**/', '').replace('*', '.*').replace('?', '.')
                      if re.search(regex_pattern, sf_line):
                          exclude = True
                          matched_pattern = pattern
                          break
              
              if exclude:
                  excluded_count += 1
                  if matched_pattern not in excluded_by_pattern:
                      excluded_by_pattern[matched_pattern] = []
                  excluded_by_pattern[matched_pattern].append(sf_line)
              else:
                  included_count += 1
                  filtered_blocks.append(block.strip() + "\nend_of_record\n")
          
          # Write filtered LCOV
          with open("coverage_filtered.lcov", "w") as f:
              f.write("\n".join(filtered_blocks))
          
          print(f"\nüìä Filtering Results:")
          print(f"   ‚úÖ Included: {included_count} files")
          print(f"   ‚ùå Excluded: {excluded_count} files")
          
          print(f"\nüìã Exclusions by pattern (top 10):")
          sorted_patterns = sorted(excluded_by_pattern.items(), key=lambda x: len(x[1]), reverse=True)
          for pattern, files in sorted_patterns[:10]:
              print(f"   {pattern}: {len(files)} files")
          PYEOF
          
          # Show stats AFTER filtering
          echo ""
          echo "üìä AFTER Filtering:"
          AFTER_FILES=$(grep -c "^SF:" coverage_filtered.lcov 2>/dev/null || echo 0)
          AFTER_LF=$(grep "^LF:" coverage_filtered.lcov 2>/dev/null | awk -F: '{sum+=$2} END {print sum+0}')
          AFTER_LH=$(grep "^LH:" coverage_filtered.lcov 2>/dev/null | awk -F: '{sum+=$2} END {print sum+0}')
          AFTER_COV=$(awk "BEGIN {printf \"%.2f\", ($AFTER_LH/$AFTER_LF)*100}")
          
          echo "  Files: $AFTER_FILES"
          echo "  Lines: $AFTER_LH / $AFTER_LF ($AFTER_COV%)"
          
          echo ""
          echo "üìä Filter Impact:"
          echo "  Files removed: $((BEFORE_FILES - AFTER_FILES))"
          echo "  Lines removed: $((BEFORE_LF - AFTER_LF))"
          echo "  Coverage change: $BEFORE_COV% ‚Üí $AFTER_COV%"
          echo ""
          echo "===== FILTERING COMPLETE ====="

      - name: Calculate Final Coverage
        id: coverage
        if: always()
        run: |
          if [ ! -f "coverage_filtered.lcov" ]; then
            echo "‚ùå No filtered coverage file"
            echo "TOTAL_COVERAGE=N/A" >> $GITHUB_OUTPUT
            echo "SUCCESS=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          LH=$(grep "^LH:" coverage_filtered.lcov | awk -F: '{sum+=$2} END {print sum+0}')
          LF=$(grep "^LF:" coverage_filtered.lcov | awk -F: '{sum+=$2} END {print sum+0}')
          FILES=$(grep -c "^SF:" coverage_filtered.lcov)
          
          echo "üìä Final Project-Wide Coverage:"
          echo "  Files analyzed: $FILES"
          echo "  Lines Hit: $LH"
          echo "  Lines Found: $LF"
          
          if [ "$LF" -gt 0 ]; then
            COVERAGE=$(awk "BEGIN {printf \"%.2f\", ($LH/$LF)*100}")
            echo "TOTAL_COVERAGE=${COVERAGE}%" >> $GITHUB_OUTPUT
            echo "FILES_ANALYZED=$FILES" >> $GITHUB_OUTPUT
            echo "LINES_HIT=$LH" >> $GITHUB_OUTPUT
            echo "LINES_TOTAL=$LF" >> $GITHUB_OUTPUT
            echo "SUCCESS=true" >> $GITHUB_OUTPUT
            echo ""
            echo "üéØ Total Coverage: ${COVERAGE}%"
          else
            echo "TOTAL_COVERAGE=0.00%" >> $GITHUB_OUTPUT
            echo "SUCCESS=false" >> $GITHUB_OUTPUT
          fi

      - name: Comment on PR
        if: steps.coverage.outputs.SUCCESS == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const coverage = '${{ steps.coverage.outputs.TOTAL_COVERAGE }}';
            const files = '${{ steps.coverage.outputs.FILES_ANALYZED }}';
            const linesHit = '${{ steps.coverage.outputs.LINES_HIT }}';
            const linesTotal = '${{ steps.coverage.outputs.LINES_TOTAL }}';
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: `## üìä Test Coverage Report

**Total Coverage:** **${coverage}**

**Details:**
- üìÅ Files Analyzed: ${files}
- ‚úÖ Lines Covered: ${linesHit}
- üìù Total Lines: ${linesTotal}

*Coverage calculated after excluding files per \`.xcodecov.yaml\` configuration*`
            });

      - name: Comment on Failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const runUrl = `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: `‚ùå Coverage check failed. [View logs](${runUrl})`
            });
